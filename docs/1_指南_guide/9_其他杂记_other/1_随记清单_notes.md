## 随记清单

说明文档概述，通过如下措施：
1、从目标组件中获取摘要描述信息，提示信息（tip、warning、danger、detail 等）  
2、从示例组件中获取（示例代码、实际 UI 效果）、摘要描述信息、提示信息（tip、warning、danger、detail 等）  
3、通过 vue-docgen-api 从目标组件中获取 defineProps、defineEmits、defineExpose、defineSlots 中获取：名称、描述、ts 类型、默认值  
4、从.ts 或.vue 文件中获取 ts 类型

能够实现：
只需在源码中写好注释，即可通过 node 命令生成说明文档，大大降低了了说明文档的维护难度。

5、谨记：遵循 json 嵌套跟随 dom 嵌套的原则（记住这点方便快速上手）
6、还额外沉淀了如下几个实用工具库（提效）：storage（封装了 localStorage、sessionStorage、cookie 的存取）、弹性布局基础类、easy api、easy mock、quick docs、爬虫工具
7、结合众多后管项目实战经验，以代码洁癖的态度，多次迭代更新，以优雅的方式处理了一个又一个问题，并尽可能地预留了扩展性，使得能够尽量避免不可预期的历史性包袱。
8、使用最新技术栈：Vue 3.x + Vite 6.x + ElementPlus 2.9.x

## 简化逻辑的体现方面

1、无需处理日期格式转换（无需将字段拆成数组、数组合成字段处理）
2、无需处理 placeholder、clearabled 的属性设置
3、无需书写表单校验规则

## 优雅解决方案

1、全局弹窗
2、全局字典（从而解决了表单 select 下拉项和表格状态标签样式、文字显示的问题）
3、弹性布局基础类
4、全局按钮
4、组件扩展与继承（AddDelList、AanyEleList）
5、useModelData 处理双向绑定
6、模板思想
7、低码配置
8、表单、表格的高度自动滚动
9、http 封装及命名规范
10、表单细节：popover、tips、示例文字、前后元素、插槽支持、BaseRender 渲染任何元素
11、全局样式替换：自定义一套核心 sass 变量（分组成规律），覆盖 element-plus 的 sass 变量，同时方便工程移植性
12、代码极致、代码洁癖，仔细考虑每一个 api，每一个组件的抽取，利于后续迭代维护性

## 待定清单

13、完全继承 UI 框架的属性
14、设置表单初始值示例
22、基础组件页面示例
26、打包优化
25、BaseImg、BaseText、UserInfo、自定义组件展示
24、给一个预览使用地址，分角色登录：superAdmin、admin、user
27、按钮防抖；表单按下 enter 键触发提交 或 搜索条件 chang（已做防抖）触发搜索；表格&表单 loading 加载提示
28、自动给组件命名  
29、打包配置让较大的三方库采用 CDN 加载方式
35、支持防抖 change 触发列表请求，或 enter 请求
46、Quick Vitepress Docs：基于 Vitepress 快速生成文档
55、精益求精，抓住细节，以弹窗的历程为例：提取弹窗 dialog 和 drawer（弹窗与弹窗内部内容解耦，用 provide 和 inject 实现，支持打开多层弹窗，弹窗宽度由内部元素决定，最大限高，自适应滚动条）-> dialog 底部按钮统一处理（确认、取消、防抖） -> 传参方式优化（由 BaseRender 解析对象，到 h 函数，到数组）-> 全局弹窗抽离出一个组件（包裹根元素）-> 弹窗内部元素自适应高度&滚动条 -> 打开或关闭弹窗时是否销毁（默认不销毁）-> dialog 关闭弹窗 closePopup 对传参处理（区分事件对象和关闭的指定弹窗）-> 简化打开/关闭弹窗的传参类型（只支持 dialog-1、数字这类参数类型）
57、考虑多场景（各种情况下的代码如何自定义覆盖等）
60、快速开发：设置代码片段、
61、高度封装之后，极小的包体积
62、请不要称它为过渡封装。封装组件的目的就是为了易用、提效，否则，为什么不通用 element-plus 提供的原有组件呢。适当的学习成本是必要的，Quick Admin 要做的就是极大地降低开发者心智负担（包含上手学习成本）。为了实现某些快捷的方式，不得不新定义一些属性来满足该需求，所以适当的学习成本是必要的。
