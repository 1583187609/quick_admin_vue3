很喜欢这样两句话：

- 代码是写给人看的，只是恰好机器能够执行。
- 过早优化是万恶之源。

开发效率取决于：团队协作流程 + 基建完善程度（基础组件完善度很重要）。

# 业务痛点

后台管理系统存在大量的重复代码。

- 重复引入 dialog、drawer 弹窗，并设置一堆统一属性（v-model、destroy、……）
- 重复写按钮，并保证样式风格、图标统一；重复写确认删除吗？等提示
- 重复写按钮权限
- 重复的正则表达式
- 定制化同样风格的组件样式设置（age、……）
- 混乱的字典管理
- 繁琐的逻辑处理（BaseCrud、……）
- 频繁组件的引用（UserInfo、……）
- 表格列宽需要频繁设置
- 表单字段宽度需要频繁设置
- 表格列或表单字段含义不清晰（缺乏 popover 提示）
- 工程移植性差

# Quick 简介

## 原则

Quick Admin 设计立意原则：全继承 + 强扩展 + 严统一 + 活配置 + 易使用 + 高效率 + 低代码 + 高内聚 + 低耦合

::: details 全继承
待完善
:::

::: details 强扩展
待完善
:::

::: details 严统一
待完善
:::

::: details 活配置
待完善
:::

::: details 易使用
待完善
:::

::: details 高效率
待完善
:::

::: details 低代码
待完善
:::

::: details 高内聚
待完善
:::

::: details 低耦合
待完善
:::

## 维度

Quick Admin 设计考虑了三个维度：开发体验、用户体验、工程移植性

::: details 开发体验

1. 清晰的组件抽离原则（方便任意组合，保持来源单一性）
2. 支持多种表单（BaseForm、SectionForm）、多种表格（BaseTable、FormTable）；极强的扩展性与维护性（内容不串，各自维护）
3. 配置 VsCode 的列表页、新增编辑页 的快速代码片段
4. 高度统一封装后，易于处理国际化
5. 高度统一封装后，有利于减少 bug 的产生
6. BaseBtn 统一做了防抖处理
7. dialog 和 drawer 内部都会自动计算自适应滚动高度
8. 联调帮助：打印请求参数、响应数据、未联调字段标红处理、错误字段类型、标红处理
9. 单双 props、父子嵌套 props
10. 自动给组件命名：免手写组件名、路由名称
11. 省事省力： popover, popconfirm 轻松拿捏

:::

::: details 用户体验

1. 更美观的空白占位（表格列空位：-）
2. 细致的用户体验：BaseCrud 列表自适应高度滚动；BaseForm 表单、弹出层内的 BaseForm、BaseSection 底部按钮固定

:::

::: details 工程移植性

1. 全局配置处理（支持覆盖）

:::

## 功能

以下是部分功能清单（细节处理清单）：

基础框架：

1. 动态路由：数据从接口获取+菜单权限控制
2. 自动路由
3. 多级菜单
4. 支持同路径不同 ID 的页面缓存

组件级别：

1. 按钮组：最多展示三个按钮，否则用更多下拉项自动包裹
2. 操作栏、额外按钮等未处理的按钮点击后会提示：点击了 Xxx 按钮
3. label 宽度自适应，每行 FormItem 个数自适应
4. 按钮简写：并支持扩展、自定义、方法判断等
5. BaseForm 统一处理 loading、文案提示，弹窗自动关闭刷新、降低开发者心智负担
6. 轻松实现电话号码（或其他）正则校验，并保证统一
7. 内置常用按钮——可覆盖、扩展、自定义（内置默认按钮样式、按钮角色权限控制、显示 popconfirm 弹出层、统一按钮位置）
8. BaseCrud 组件跟随自适应表格内容高度，Dialog 内的 BaseCrud 高度也会跟随自定义
9. 导入、导出统一默认处理或自定义处理
10. 表格的 columns 的 prop 支持.属性访问，并验证
11. 表格拖动排序
12. BaseCrud 中的表格部分分块显示
13. 页签缓存、实现同路由地址不同 ID 缓存
14. 解放按钮的角色权限控制，只需配置一次(轻松实现按钮权限问题，一处配置根据角色来处理，也可覆盖)
15. 弹性布局基础类：提升静态页面开发效率约 30%
16. Quick API：免手写 api，以及请求参数、响应参数的 ts 类型

全局级别：

1. 全局弹窗：openPopup/closePopup 实现轻松打开/关闭 drawer、dialog 弹窗。支持打开多个。
2. 统一提示：统一处理`新增成功`、`确认删除吗？`等文案提示（文案可不传，均有默认值）
3. 全局字典：下拉项可直接写字典名称。统一管理同步、异步字典数据，并有针对性进行存储策略（是否使用本地缓存，减少网络请求次数）

扩展级别：

1. 自定义工程组件嵌入，减少基础代码开发
2. 轻松实现工程移植主题换肤、工程基础属性配置（支持组件定制化配置）

## 优势清单（使用理由）

1. 采用创新的架构设计，实现了高度封装统一与良好的扩展性（这两者原本是互相矛盾的）
2. 对比开源 Pro 类三方库，逻辑更清晰、代码更少、开发效率更高
3. 整套全局基础组件，已经过一个完整项目验证；较成熟
4. 按钮位置、样式、图标等高度统一；表格列宽统一
5. 配置项足够强大（工程移植性、全局配置、局部配置等层层覆盖，遵循子级优先原则）
6. 易上手；json 嵌套原则遵循 dom 嵌套规则
7. tree-shaking 优化
8. 常规封装使用度只能达到 90%左右，但 quick 能达到 100%
9. 同类比较：

其他库存在的问题：

- JSON 嵌套层级过深，弹窗及弹窗内部的内容逻辑未解耦
- 查询列表底部分页自动跟随高度，超出后自动滚动
- 极简变量控制`type: 'input', slot: true`，始终只用 `type: 'input', type: 'custom'` 来进行控制

## 开发规范清单

1. 页面名小写短横线链接、组件名大驼峰
2. 文件夹、文件命名、TS 命名、JS 变量命名等规则
3. 逻辑运算符 && 控制字段显示或隐藏（单个可用 && ，多个可用 `...(true ? [{}] : [])`）
4. 模板（`T_`开头）、字典（`D_`开头）、api（大驼峰）、后端字段（下划线）、其他 js 变量（小驼峰）均是为了不重复，且方便全局修改

# 总结

Quick Admin 从开发、联调、修复 bug、迭代维护多个维度，提升后台管理系统开发效率约 30%。
其中从开发到上线阶段，能提效约：40% ~ 50%。对后续的影响更为远大。
理解了设计思路后，一定能够很快上手，并相信你一定会爱上他。
